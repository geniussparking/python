参考资料：
http://www.cnblogs.com/alex3714/articles/5143440.html     有所有的匹配格式
匹配格式

模式	描述
^	匹配字符串的开头
$	匹配字符串的末尾。
.	匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
[...]	用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
[^...]	不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
*	匹配0个或多个的表达式。   注意这个和下面的+的区别，*会把0个也匹配出来，这样会导致结果列表里有空元素['']
+	匹配1个或多个的表达式。   不想把0也匹配就用这个
?	匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
{ n}	 
{ n,}	精确匹配n个前面表达式。
{ n, m}	匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
a| b	匹配a或b
()	G匹配括号内的表达式，也表示一个组
(?imx)	正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
(?-imx)	正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
(?:)	类似 (...), 但是不表示一个组
(?imx:)	在括号中使用i, m, 或 x 可选标志
(?-imx:)	在括号中不使用i, m, 或 x 可选标志
(?#...)	注释.
(?=)	前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
(?!)	前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
(?>)	匹配的独立模式，省去回溯。
\w	匹配字母数字
\W	匹配非字母数字
\s	匹配任意空白字符，等价于 [\t\n\r\f].
\S	匹配任意非空字符
\d	匹配任意数字，等价于 [0-9].
\D	匹配任意非数字
\A	匹配字符串开始
\Z	匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c
\z	匹配字符串结束
\G	匹配最后匹配完成的位置。
\b	匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B	匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\n, \t, 等.	匹配一个换行符。匹配一个制表符。等
\1...\9	匹配第n个分组的子表达式。
\10	匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式。



使用正则的基本格式
#!/usr/bin/env python
import re                       # 引用正则模块
data_source = "134aa1212abcdfess"     # 数据源
pattern = "[0-9]{0,10}"                 # 查找模型, 语法跟php一样
m = re.match(pattern, data_source)  # 将查找的结果给m, 这里的match()方法是从开头匹配
#print(m)               # 匹配到之后打印出： <_sre.SRE_Match object; span=(0, 3), match='abc'>
if m:                   #  要用一个if判断，如果m里面有东西就打印，否则会报错
    print(m.group())                    # 使用一个group()方法就可以查看找到了什么

findall()方法，查找出全部
#!/usr/bin/env python
import re
data_source = "134aa1212abcdfess"
pattern = "[0-9]{1,2}"        # 注意这里{}里面的范围很重要，如果是{1,2}表示1个或2个，{2}表示2个
m = re.findall(pattern, data_source)
if m:
    print(m)      # 注意这里就没有group()了

打印出：
['13', '4', '12', '12']


re.search(), 在目标字符串中去查找，跟match不同的是不一定从头部开始找，只要字符串里面有，就能找到，需要用m.group()打印出来
re.sub()  替换
m = re.sub("\d+","|","abc123def345")
print(m)    #打印出 abc|def|   , 这里不用m.group()打印

指定替换次数：
m = re.sub("\d+","|","abc123def345ggg123",count=2)
print(m)    # 打印出：abc|def|ggg123

从起始、结束的地方开始查找：
#!/usr/bin/env python
import re
m = re.sub("^\d+$","|","abc123def345ggg123",count=2)   # ^表示起始地方，$表示结束地方，^\d+$  这个的意思是整个字符串都是数字，查找1个或多个数字
print(m)   # 这里因为没有找到，所以不会发生替换

re.match("[0-9]")  # 匹配数字
re.match("[a-zA-Z0-9@]")   # 匹配数字大小写字母再加@
re.match("[0123456789]")  #匹配数字

#!/usr/bin/env python
import re
string="192.168.2.2"
m = re.match("[0-9]{1,3}\.",string)   # 这样打印出：192.
print(m.group())

#!/usr/bin/env python
import re
string="192.168.2.2"
m = re.match("([0-9]{1,3}\.){3}[0-9]{1,3}",string)    # 中间那个{3}表示前面()内的正则匹配3次
print(m.group())    # 这里能直接打印出整个IP地址


#!/usr/bin/env python
import re
string="192.168.2.2"
m = re.split("\.",string)  # 用规则分割目标字符
print(m)    # 打印['192', '168', '2', '2']
